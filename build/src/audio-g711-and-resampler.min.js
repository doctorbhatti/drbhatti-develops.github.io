'use strict';function Resampler(b,a,c,e,f){this.fromSampleRate=b;this.toSampleRate=a;this.channels=c|0;this.outputBufferSize=e;this.noReturn=!!f;this.initialize()}
Resampler.prototype.initialize=function(){if(0<this.fromSampleRate&&0<this.toSampleRate&&0<this.channels)this.fromSampleRate==this.toSampleRate?(this.resampler=this.bypassResampler,this.ratioWeight=1):(this.fromSampleRate<this.toSampleRate?(this.compileLinearInterpolationFunction(),this.lastWeight=1):(this.compileMultiTapFunction(),this.tailExists=!1,this.lastWeight=0),this.ratioWeight=this.fromSampleRate/this.toSampleRate,this.initializeBuffers());else throw Error("Invalid settings specified for the resampler.");
};Resampler.prototype.compileLinearInterpolationFunction=function(){let b=`var bufferLength = buffer.length;\
	var outLength = this.outputBufferSize;\
	if ((bufferLength % ${this.channels}) == 0) {\
		if (bufferLength > 0) {\
			var ratioWeight = this.ratioWeight;\
			var weight = this.lastWeight;\
			var firstWeight = 0;\
			var secondWeight = 0;\
			var sourceOffset = 0;\
			var outputOffset = 0;\
			var outputBuffer = this.outputBuffer;\
			for (; weight < 1; weight += ratioWeight) {\
				secondWeight = weight % 1;\
				firstWeight = 1 - secondWeight;`;for(var a=0;a<this.channels;++a)b+=`outputBuffer[outputOffset++] = (this.lastOutput[${a}] * firstWeight) + (buffer[${a}] * secondWeight);`;b+=`}\
			weight -= 1;\
			for (bufferLength -= ${this.channels}, sourceOffset = Math.floor(weight) * ${this.channels}; outputOffset < outLength && sourceOffset < bufferLength;) {\
				secondWeight = weight % 1;\
				firstWeight = 1 - secondWeight;`;for(a=0;a<this.channels;++a)b+=`outputBuffer[outputOffset++] = (buffer[sourceOffset${0<a?` + ${a}`:""}] * firstWeight) + (buffer[sourceOffset + ${this.channels+a}] * secondWeight);`;b+=`weight += ratioWeight;\
				sourceOffset = Math.floor(weight) * ${this.channels};\
			}`;for(a=0;a<this.channels;++a)b+=`this.lastOutput[${a}] = buffer[sourceOffset++];`;this.resampler=Function("buffer",b+'this.lastWeight = weight % 1;\t\t\treturn this.bufferSlice(outputOffset);\t\t}\t\telse {\t\t\treturn (this.noReturn) ? 0 : [];\t\t}\t}\telse {\t\tthrow(new Error("Buffer was of incorrect sample length."));\t}')};Resampler.prototype.compileMultiTapFunction=function(){let b=`var bufferLength = buffer.length;\
	var outLength = this.outputBufferSize;\
	if ((bufferLength % ${this.channels}) == 0) {\
		if (bufferLength > 0) {\
			var ratioWeight = this.ratioWeight;\
			var weight = 0;`;for(var a=0;a<this.channels;++a)b+=`var output${a} = 0;`;b+="var actualPosition = 0;\t\t\tvar amountToNext = 0;\t\t\tvar alreadyProcessedTail = !this.tailExists;\t\t\tthis.tailExists = false;\t\t\tvar outputBuffer = this.outputBuffer;\t\t\tvar outputOffset = 0;\t\t\tvar currentPosition = 0;\t\t\tdo {\t\t\t\tif (alreadyProcessedTail) {\t\t\t\t\tweight = ratioWeight;";for(a=0;a<this.channels;++a)b+=`output${a} = 0;`;b+="}\t\t\t\telse {\t\t\t\t\tweight = this.lastWeight;";for(a=0;a<
this.channels;++a)b+=`output${a} = this.lastOutput[${a}];`;b+="alreadyProcessedTail = true;\t\t\t\t}\t\t\t\twhile (weight > 0 && actualPosition < bufferLength) {\t\t\t\t\tamountToNext = 1 + actualPosition - currentPosition;\t\t\t\t\tif (weight >= amountToNext) {";for(a=0;a<this.channels;++a)b+=`output${a} += buffer[actualPosition++] * amountToNext;`;b+="currentPosition = actualPosition;\t\t\t\t\t\tweight -= amountToNext;\t\t\t\t\t}\t\t\t\t\telse {";for(a=0;a<this.channels;++a)b+=`output${a} += buffer[actualPosition${0<
a?` + ${a}`:""}] * weight;`;b+="currentPosition += weight;\t\t\t\t\t\tweight = 0;\t\t\t\t\t\tbreak;\t\t\t\t\t}\t\t\t\t}\t\t\t\tif (weight == 0) {";for(a=0;a<this.channels;++a)b+=`outputBuffer[outputOffset++] = output${a} / ratioWeight;`;b+="}\t\t\t\telse {\t\t\t\t\tthis.lastWeight = weight;";for(a=0;a<this.channels;++a)b+=`this.lastOutput[${a}] = output${a};`;this.resampler=Function("buffer",b+'this.tailExists = true;\t\t\t\t\tbreak;\t\t\t\t}\t\t\t} while (actualPosition < bufferLength && outputOffset < outLength);\t\t\treturn this.bufferSlice(outputOffset);\t\t}\t\telse {\t\t\treturn (this.noReturn) ? 0 : [];\t\t}\t}\telse {\t\tthrow(new Error("Buffer was of incorrect sample length."));\t}')};
Resampler.prototype.bypassResampler=function(b){return this.noReturn?(this.outputBuffer=b,b.length):b};Resampler.prototype.bufferSlice=function(b){if(this.noReturn)return b;try{return this.outputBuffer.subarray(0,b)}catch(a){try{return this.outputBuffer.length=b,this.outputBuffer}catch(c){return this.outputBuffer.slice(0,b)}}};
Resampler.prototype.initializeBuffers=function(){try{this.outputBuffer=new Float32Array(this.outputBufferSize),this.lastOutput=new Float32Array(this.channels)}catch(b){this.outputBuffer=[],this.lastOutput=[]}};/*
 g711
 Copyright(c) 2011 Jo?o Martins <madjackoo@gmail.com>
 MIT Licensed
 */
const G711={BIAS:132,CLIP:32635,tables:{alaw:{compress:[1,1,2,2,3,3,3,3,4,4,4,4,4,4,4,4,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,5,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,6,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7,7],decompress:[-5504,-5248,-6016,-5760,-4480,-4224,-4992,-4736,-7552,-7296,-8064,-7808,-6528,-6272,-7040,-6784,-2752,-2624,-3008,-2880,-2240,-2112,-2496,-2368,-3776,-3648,-4032,-3904,-3264,-3136,
  -3520,-3392,-22016,-20992,-24064,-23040,-17920,-16896,-19968,-18944,-30208,-29184,-32256,-31232,-26112,-25088,-28160,-27136,-11008,-10496,-12032,-11520,-8960,-8448,-9984,-9472,-15104,-14592,-16128,-15616,-13056,-12544,-14080,-13568,-344,-328,-376,-360,-280,-264,-312,-296,-472,-456,-504,-488,-408,-392,-440,-424,-88,-72,-120,-104,-24,-8,-56,-40,-216,-200,-248,-232,-152,-136,-184,-168,-1376,-1312,-1504,-1440,-1120,-1056,-1248,-1184,-1888,-1824,-2016,-1952,-1632,-1568,-1760,-1696,-688,-656,-752,-720,
  -560,-528,-624,-592,-944,-912,-1008,-976,-816,-784,-880,-848,5504,5248,6016,5760,4480,4224,4992,4736,7552,7296,8064,7808,6528,6272,7040,6784,2752,2624,3008,2880,2240,2112,2496,2368,3776,3648,4032,3904,3264,3136,3520,3392,22016,20992,24064,23040,17920,16896,19968,18944,30208,29184,32256,31232,26112,25088,28160,27136,11008,10496,12032,11520,8960,8448,9984,9472,15104,14592,16128,15616,13056,12544,14080,13568,344,328,376,360,280,264,312,296,472,456,504,488,408,392,440,424,88,72,120,104,24,8,56,40,216,
  200,248,232,152,136,184,168,1376,1312,1504,1440,1120,1056,1248,1184,1888,1824,2016,1952,1632,1568,1760,1696,688,656,752,720,560,528,624,592,944,912,1008,976,816,784,880,848]}},encode:function(b,a){b.constructor==Array&&(b.byteLength=2*b.length);a=new ArrayBuffer(b.byteLength/2);a=new Int8Array(a);for(let d=0;d<b.byteLength/2;d++){var c=new ArrayBuffer(2),e=new ArrayBuffer(1),f=new Int16Array(c);c=new Int8Array(e);e=~b[d]>>8&128;128!=e&&(f[0]=-b[d],b[d]=f[0]);b[d]>G711.CLIP&&(b[d]=G711.CLIP);if(256<=
  b[d]){f=G711.tables.alaw.compress[b[d]>>8&127];var g=b[d]>>f+3&15;c[0]=f<<4|g}else c[0]=b[d]>>4;c[0]=c[0]^e^85;a[d]=c[0]}return a},decode:function(b,a){a=a||{};"undefined"===typeof b.byteLength&&(b.byteLength=b.length);var c=new ArrayBuffer(b.byteLength*(a.floating_point?4:2));a=new Float32Array(c);for(let e=0;e<b.byteLength;e++){c=new ArrayBuffer(2);c=new Int8Array(c);const f=G711.tables.alaw.decompress[b[e]&255];c[0]=f;c[1]=f>>8;c=(new Int16Array(c.buffer))[0];a[e]=c/32768}return a}};
